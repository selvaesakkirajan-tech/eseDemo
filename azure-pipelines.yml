trigger:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - apps/python-api/**
      - infra/**
      - manifests/**

variables:
  # Link the variable group from Library
  - group: azure-cicd

  # Pipeline-level variables
  - name: DOCKER_IMAGE_NAME
    value: python-api
  - name: HELM_VERSION
    value: '3.12.0'
  - name: TERRAFORM_VERSION
    value: '1.5.0'

stages:
  - stage: Build
    displayName: 'Build & Test'
    jobs:
      - job: BuildAndTest
        displayName: 'Build Docker Image & Run Tests'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: UsePythonVersion@0
            inputs:
              versionSpec: '3.11'
            displayName: 'Set Python version to 3.11'

          - task: Bash@3
            displayName: 'Install dependencies'
            inputs:
              targetType: 'inline'
              script: |
                cd apps/python-api
                pip install --upgrade pip
                pip install -r src/requirements.txt

          - task: Bash@3
            displayName: 'Run unit tests with coverage'
            inputs:
              targetType: 'inline'
              script: |
                cd apps/python-api
                python -m pytest tests/ -v --junitxml=junit.xml --cov=src --cov-report=xml --cov-report=html

          - task: PublishTestResults@2
            displayName: 'Publish test results'
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: 'apps/python-api/junit.xml'
              testRunTitle: 'API Unit Tests'
            condition: always()

          - task: PublishCodeCoverageResults@1
            displayName: 'Publish code coverage'
            inputs:
              codeCoverageTool: Cobertura
              summaryFileLocation: 'apps/python-api/coverage.xml'
              reportDirectory: 'apps/python-api/htmlcov'
            condition: always()

          - task: Docker@2
            displayName: 'Build Docker image'
            inputs:
              command: 'build'
              containerRegistry: 'acr-connection'
              Dockerfile: 'apps/python-api/Dockerfile'
              repository: '$(DOCKER_IMAGE_NAME)'
              tags: |
                $(Build.BuildId)
                latest
              arguments: '--no-cache'

          - task: Docker@2
            displayName: 'Push Docker image to ACR'
            inputs:
              command: 'push'
              containerRegistry: 'acr-connection'
              repository: '$(DOCKER_IMAGE_NAME)'
              tags: |
                $(Build.BuildId)
                latest

  - stage: Deploy
    displayName: 'Deploy to AKS (Dev)'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - job: ProvisionInfra
        displayName: 'Provision Infrastructure with Terraform'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Install Terraform'
            inputs:
              targetType: 'inline'
              script: |
                TERRAFORM_VERSION="$(TERRAFORM_VERSION)"
                wget -q "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip"
                unzip -o "terraform_${TERRAFORM_VERSION}_linux_amd64.zip"
                sudo mv terraform /usr/local/bin/
                terraform --version

          - task: AzureCLI@2
            displayName: 'Terraform Init'
            inputs:
              azureSubscription: 'azure-connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              workingDirectory: '$(Build.SourcesDirectory)/infra'
              inlineScript: |
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_CLIENT_SECRET=$servicePrincipalKey
                export ARM_TENANT_ID=$tenantId
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                terraform init \
                  -backend-config="resource_group_name=$(TF_STATE_RG)" \
                  -backend-config="storage_account_name=$(TF_STATE_STORAGE)" \
                  -backend-config="container_name=tfstate" \
                  -backend-config="key=dev.tfstate"

                terraform validate

          - task: AzureCLI@2
            displayName: 'Terraform Plan'
            inputs:
              azureSubscription: 'azure-connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              workingDirectory: '$(Build.SourcesDirectory)/infra'
              inlineScript: |
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_CLIENT_SECRET=$servicePrincipalKey
                export ARM_TENANT_ID=$tenantId
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)

                TFVARS_FILE="$(Build.SourcesDirectory)/infra/env/dev/terraform.tfvars"

                if [ ! -f "$TFVARS_FILE" ]; then
                  echo "##vso[task.logissue type=error]Missing tfvars file: $TFVARS_FILE"
                  echo "Contents of infra/env for debugging:"
                  ls -la "$(Build.SourcesDirectory)/infra/env" || true
                  exit 1
                fi

                # Import pre-existing Resource Group into Terraform state (idempotent)
                RG_NAME=$(terraform console -var-file="$TFVARS_FILE" <<< '"${var.environment}-${var.project}-rg"' | tr -d '"')
                RG_ID="/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/$RG_NAME"

                if az group show --name "$RG_NAME" >/dev/null 2>&1; then
                  if ! terraform state show azurerm_resource_group.main >/dev/null 2>&1; then
                    echo "Resource Group exists but is not in Terraform state. Importing: $RG_ID"
                    terraform import -var-file="$TFVARS_FILE" azurerm_resource_group.main "$RG_ID"
                  else
                    echo "Resource Group already present in Terraform state: $RG_NAME"
                  fi
                fi

                terraform plan -var-file="$TFVARS_FILE" -out=tfplan

          - task: AzureCLI@2
            displayName: 'Terraform Apply'
            inputs:
              azureSubscription: 'azure-connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              workingDirectory: '$(Build.SourcesDirectory)/infra'
              inlineScript: |
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_CLIENT_SECRET=$servicePrincipalKey
                export ARM_TENANT_ID=$tenantId
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)

                # Remove App Insights from state if it exists (allows clean recreation without workspace_id conflict)
                if terraform state show module.appinsights.azurerm_application_insights.main >/dev/null 2>&1; then
                  echo "Removing stale App Insights from Terraform state..."
                  terraform state rm module.appinsights.azurerm_application_insights.main
                fi

                terraform apply -auto-approve tfplan

          - task: AzureCLI@2
            displayName: 'Get Application Gateway Public IP'
            inputs:
              azureSubscription: 'azure-connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              workingDirectory: '$(Build.SourcesDirectory)/infra'
              inlineScript: |
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_CLIENT_SECRET=$servicePrincipalKey
                export ARM_TENANT_ID=$tenantId
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                APPGW_IP=$(terraform output -raw appgw_public_ip)
                echo "##vso[task.setvariable variable=APPGW_PUBLIC_IP;isOutput=true]$APPGW_IP"
                echo "==========================================="
                echo "Application Gateway Deployment Successful!"
                echo "==========================================="
                echo "Public IP Address: $APPGW_IP"
                echo "API Endpoint: http://$APPGW_IP/sum?a=1&b=2"
                echo "Documentation: File APPLICATION_GATEWAY_SETUP.md"
                echo "==========================================="

      - job: DeployToAKS
        displayName: 'Deploy to AKS with Helm'
        dependsOn: ProvisionInfra
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: HelmInstaller@1
            displayName: 'Install Helm'
            inputs:
              helmVersionToInstall: '$(HELM_VERSION)'

          - task: Bash@3
            displayName: 'Get AKS credentials'
            inputs:
              targetType: 'inline'
              script: |
                az account set --subscription $(AZURE_SUBSCRIPTION_ID)
                az aks get-credentials --resource-group $(AKS_RESOURCE_GROUP) --name $(AKS_CLUSTER_NAME)

          - task: Bash@3
            displayName: 'Update Helm chart values'
            inputs:
              targetType: 'inline'
              script: |
                REGISTRY_URL=$(ACR_REGISTRY_URL)
                IMAGE_TAG=$(Build.BuildId)
                sed -i "s|<registry>|${REGISTRY_URL}|g" manifests/helm/python-api/values.yaml
                sed -i "s|<image_tag>|${IMAGE_TAG}|g" manifests/helm/python-api/values.yaml

          - task: Bash@3
            displayName: 'Deploy Helm chart to AKS'
            inputs:
              targetType: 'inline'
              script: |
                helm upgrade \
                  --install python-api \
                  --namespace default \
                  --values manifests/helm/python-api/values.yaml \
                  --set image.repository="$(ACR_REGISTRY_URL)/$(DOCKER_IMAGE_NAME)" \
                  --set image.tag="$(Build.BuildId)" \
                  manifests/helm/python-api

          - task: Bash@3
            displayName: 'Verify Helm deployment'
            inputs:
              targetType: 'inline'
              script: |
                kubectl rollout status deployment/python-api -n default --timeout=5m
                kubectl get pods -n default
                kubectl get svc -n default